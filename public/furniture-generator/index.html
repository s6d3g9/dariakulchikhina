<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>3D Furniture Voxel Editor</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#fdfdfd;
  font-family:"SF Mono","Fira Code","Courier New",Courier,monospace;color:#000}
#app{display:grid;width:100%;height:100%;
  grid-template-columns:320px 1fr;grid-template-rows:auto 1fr auto}

#cats{grid-column:1/3;display:flex;border-bottom:2px solid #000;background:#fff}
.cat-btn{flex:1;padding:9px 4px;font:inherit;font-size:10px;letter-spacing:.07em;
  text-transform:uppercase;background:#fff;border:none;border-right:2px solid #000;
  cursor:pointer;transition:background .15s}
.cat-btn:last-child{border-right:none}
.cat-btn.active{background:#000;color:#fff}
.cat-btn:hover:not(.active){background:#eee}

#left{grid-column:1;grid-row:2;border-right:2px solid #000;
  overflow-y:auto;display:flex;flex-direction:column}
.sec{padding:7px 10px;border-bottom:2px solid #000}
.sec-head{font-size:9px;letter-spacing:.1em;text-transform:uppercase;margin-bottom:5px}

.pal-row{display:flex;flex-wrap:wrap;gap:3px}
.pal-btn{display:flex;align-items:center;gap:4px;padding:3px 7px;font:inherit;font-size:8.5px;
  letter-spacing:.04em;text-transform:uppercase;border:2px solid #000;background:#fff;
  cursor:pointer;transition:all .12s;line-height:1.2}
.pal-btn .sw{width:10px;height:10px;border:1px solid #000;flex-shrink:0}
.pal-btn.active{background:#000;color:#fff}
.pal-btn.active .sw{border-color:#fff}
.pal-btn:hover:not(.active){background:#f0f0f0}

.preset-row{display:flex;flex-wrap:wrap;gap:3px;margin-top:4px}
.preset-btn{padding:3px 7px;font:inherit;font-size:8px;letter-spacing:.05em;text-transform:uppercase;
  border:1.5px solid #000;background:#fff;cursor:pointer;transition:all .12s;line-height:1.2}
.preset-btn:hover{background:#eee}
.preset-btn.active{background:#000;color:#fff}

.dim-row{display:flex;gap:6px;margin-bottom:4px;flex-wrap:wrap;align-items:center}
.dim-row label{font-size:9px;text-transform:uppercase;letter-spacing:.05em;
  display:flex;align-items:center;gap:4px}
.dim-row input{width:52px;font:inherit;font-size:13px;text-align:center;
  border:2px solid #000;padding:2px}
.dim-auto{display:flex;gap:12px;margin-top:2px;padding:5px 0;
  border-top:1px solid #ccc;font-size:9px;text-transform:uppercase;letter-spacing:.05em}
.dim-auto .val{font-weight:700;font-size:12px}

.tog-row{display:flex;gap:6px;margin-bottom:5px;flex-wrap:wrap}
.tog-btn{display:flex;align-items:center;gap:5px;padding:4px 8px;font:inherit;font-size:8.5px;
  letter-spacing:.06em;text-transform:uppercase;border:2px solid #000;background:#fff;
  cursor:pointer;transition:all .12s;line-height:1.2}
.tog-btn .indicator{width:10px;height:10px;border:1.5px solid #000;background:#fff;flex-shrink:0}
.tog-btn.on .indicator{background:#000}
.tog-btn.on{background:#f0f0f0}
.tog-btn:hover{background:#eee}

#view{grid-column:2;grid-row:2;position:relative;overflow:hidden}
#view canvas{display:block;width:100%;height:100%}
#click-hint{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);
  font:inherit;font-size:9px;letter-spacing:.06em;text-transform:uppercase;
  color:#999;pointer-events:none}

#bar{grid-column:1/3;border-top:2px solid #000;background:#fff;
  display:flex;align-items:center;padding:5px 14px;gap:14px;flex-wrap:wrap}
#bar .info{font-size:10px;letter-spacing:.06em;text-transform:uppercase}
#bar .info span{font-weight:700}
#bar .spacer{flex:1}
.bar-btn{font:inherit;font-size:10px;letter-spacing:.08em;text-transform:uppercase;
  padding:5px 12px;border:2px solid #000;background:#fff;cursor:pointer;transition:all .12s}
.bar-btn:hover{background:#000;color:#fff}

#left::-webkit-scrollbar{width:4px}
#left::-webkit-scrollbar-thumb{background:#000}
</style>
</head>
<body>
<div id="app">
  <div id="cats">
    <button class="cat-btn active" data-cat="wardrobe">Шкаф-купе</button>
    <button class="cat-btn" data-cat="bookcase">Книжный шкаф</button>
    <button class="cat-btn" data-cat="shoes">Обувной шкаф</button>
    <button class="cat-btn" data-cat="hallway">Прихожая</button>
    <button class="cat-btn" data-cat="shelving">Стеллаж</button>
    <button class="cat-btn" data-cat="kitchen">Кухня</button>
  </div>

  <div id="left">
    <div class="sec" id="palette">
      <h3 class="sec-head">Тип отделения</h3>
      <div class="pal-row" id="pal-row"></div>
      <div style="margin-top:4px;display:flex;gap:4px">
        <button class="pal-btn" id="eraser-btn" style="border-style:dashed">
          <span class="sw" style="background:#fff"></span>Ластик
        </button>
      </div>
      <h3 class="sec-head" style="margin-top:8px">Пресеты</h3>
      <div class="preset-row" id="preset-row"></div>
    </div>

    <div class="sec" id="dims-panel">
      <h3 class="sec-head">Размеры</h3>
      <div class="dim-row">
        <label>Комната Ш <input type="number" id="roomW" value="400" min="100" max="1200" step="10"/> см</label>
        <label>Комната Г <input type="number" id="roomD" value="400" min="100" max="1200" step="10"/> см</label>
      </div>
      <div class="dim-row">
        <label>Высота <input type="number" id="dimH" value="240" min="30" max="350" step="5"/> см</label>
      </div>
      <div class="dim-auto">
        <div>Ш мебели: <span class="val" id="auto-w">—</span></div>
        <div>Г мебели: <span class="val" id="auto-d">—</span></div>
        <div>В мебели: <span class="val" id="auto-h">—</span></div>
      </div>
    </div>

    <div class="sec" id="subdiv-panel">
      <h3 class="sec-head">Деление секций</h3>
      <div class="tog-row">
        <button class="tog-btn on" id="tog-h"><span class="indicator"></span>По высоте</button>
        <button class="tog-btn on" id="tog-w"><span class="indicator"></span>По ширине</button>
        <button class="tog-btn on" id="tog-d"><span class="indicator"></span>По глубине</button>
      </div>
      <div id="subdiv-inputs">
        <div class="dim-row subdiv-for" data-for="1">
          <label>Полка <input type="number" id="shelfH" value="30" min="10" max="120" step="5"/> см</label>
        </div>
        <div class="dim-row subdiv-for" data-for="3">
          <label>Ящик <input type="number" id="drawerH" value="20" min="8" max="80" step="2"/> см</label>
        </div>
        <div class="dim-row subdiv-for" data-for="4">
          <label>Открытая <input type="number" id="openH" value="35" min="10" max="120" step="5"/> см</label>
        </div>
        <div class="dim-row subdiv-for" data-for="5">
          <label>Обувь <input type="number" id="shoeH" value="18" min="8" max="60" step="2"/> см</label>
        </div>
        <div class="dim-row subdiv-for" data-for="6">
          <label>Сапоги <input type="number" id="bootH" value="35" min="15" max="80" step="5"/> см</label>
        </div>
        <div class="dim-row subdiv-for" data-for="7">
          <label>Книги <input type="number" id="bookH" value="30" min="10" max="80" step="5"/> см</label>
        </div>
      </div>
    </div>
  </div>

  <div id="view">
    <div id="click-hint">ЛКМ — поставить кубик · Ластик — удалить · Перетаскивание — вращение</div>
  </div>

  <div id="bar">
    <div class="info">Секций: <span id="info-regions">0</span></div>
    <div class="info">Мебель: <span id="info-size">—</span></div>
    <div class="spacer"></div>
    <button class="bar-btn" id="btn-clear">Очистить всё</button>
    <button class="bar-btn" id="btn-reset-cam">Сброс камеры</button>
  </div>
</div>

<script type="importmap">
{"imports":{
  "three":"https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
  "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
}}
</script>
<script type="module">
import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

/* ═══════════════════════  TYPES  ═══════════════════════ */
const TYPES={
  shelf:  {id:1,label:'Полка',color:'#a8d8ea'},
  hanging:{id:2,label:'Штанга',color:'#b5eaaa'},
  drawer: {id:3,label:'Ящик',color:'#f5c385'},
  open:   {id:4,label:'Открытая секция',color:'#fff3b0'},
  shoeLow:{id:5,label:'Обувь низкая',color:'#f0b0c0'},
  shoeHi: {id:6,label:'Сапоги',color:'#d5b0f0'},
  books:  {id:7,label:'Книги',color:'#b0d0f0'},
  top:    {id:8,label:'Антресоль',color:'#d0d0d0'},
  sink:   {id:9,label:'Мойка',color:'#8ecae6'},
  cooktop:{id:10,label:'Варочная панель',color:'#e07a5f'},
  oven:   {id:11,label:'Духовка',color:'#c97b3d'},
  dishw:  {id:12,label:'Посудомойка',color:'#81b29a'},
};
const TYPE_BY_ID={};
for(const[k,v]of Object.entries(TYPES)) TYPE_BY_ID[v.id]={...v,key:k};
const CAT_TYPES={
  wardrobe:['shelf','hanging','drawer','open','top'],
  bookcase:['books','shelf','drawer','open'],
  shoes:['shoeLow','shoeHi','drawer','shelf'],
  hallway:['hanging','shoeLow','shoeHi','drawer','shelf','open'],
  shelving:['shelf','open','books','drawer'],
  kitchen:['shelf','drawer','open','top','sink','cooktop','oven','dishw'],
};

/* ═══════════════════════  VOXEL GRID  ═══════════════════════ */
const GX=20, GY=20, GZ=20;
let voxels=new Uint8Array(GX*GY*GZ);
function vIdx(x,y,z){return x+y*GX+z*GX*GY}
function vGet(x,y,z){if(x<0||x>=GX||y<0||y>=GY||z<0||z>=GZ)return 0;return voxels[vIdx(x,y,z)]}
function vSet(x,y,z,v){voxels[vIdx(x,y,z)]=v}
function vClear(){voxels.fill(0)}
function fillBox(x1,y1,z1,x2,y2,z2,v){
  for(let z=Math.max(0,z1);z<=Math.min(GZ-1,z2);z++)
    for(let y=Math.max(0,y1);y<=Math.min(GY-1,y2);y++)
      for(let x=Math.max(0,x1);x<=Math.min(GX-1,x2);x++) vSet(x,y,z,v)}

/* ═══════════════════════  3D PRESETS  ═══════════════════════ */
const T=TYPES;
const CATEGORY_PRESETS={
  wardrobe:[
    {name:'Классика',fill:()=>{
      fillBox(0,18,0,19,19,2,T.top.id);
      fillBox(0,6,0,9,17,2,T.hanging.id);fillBox(10,11,0,19,17,2,T.shelf.id);
      fillBox(10,6,0,19,10,2,T.shelf.id);
      fillBox(0,3,0,9,5,2,T.drawer.id);fillBox(10,3,0,19,5,2,T.drawer.id);
      fillBox(0,0,0,19,2,2,T.shelf.id)}},
    {name:'Компакт',fill:()=>{
      fillBox(0,18,0,19,19,2,T.top.id);
      fillBox(0,5,0,19,17,2,T.hanging.id);
      fillBox(0,2,0,19,4,2,T.drawer.id);fillBox(0,0,0,19,1,2,T.shelf.id)}},
    {name:'Органайзер',fill:()=>{
      fillBox(0,18,0,19,19,2,T.top.id);
      fillBox(0,10,0,4,17,2,T.shelf.id);fillBox(5,10,0,14,17,2,T.hanging.id);fillBox(15,10,0,19,17,2,T.shelf.id);
      fillBox(0,5,0,4,9,2,T.drawer.id);fillBox(5,5,0,14,9,2,T.shelf.id);fillBox(15,5,0,19,9,2,T.drawer.id);
      fillBox(0,0,0,19,4,2,T.shelf.id)}},
  ],
  bookcase:[
    {name:'Классика',fill:()=>{
      for(let i=0;i<5;i++)fillBox(0,i*4,0,19,i*4+3,1,T.books.id)}},
    {name:'С ящиками',fill:()=>{
      for(let i=0;i<4;i++)fillBox(0,i*4+4,0,19,i*4+7,1,T.books.id);
      fillBox(0,0,0,19,3,1,T.drawer.id)}},
    {name:'Смешанный',fill:()=>{
      fillBox(0,12,0,9,19,1,T.books.id);fillBox(10,12,0,19,19,1,T.open.id);
      fillBox(0,6,0,9,11,1,T.books.id);fillBox(10,6,0,19,11,1,T.shelf.id);
      fillBox(0,0,0,19,5,1,T.drawer.id)}},
  ],
  shoes:[
    {name:'Классика',fill:()=>{
      fillBox(0,14,0,19,19,2,T.shoeHi.id);
      fillBox(0,6,0,19,13,2,T.shoeLow.id);
      fillBox(0,0,0,19,5,2,T.drawer.id)}},
    {name:'Компакт',fill:()=>{
      fillBox(0,10,0,19,19,1,T.shoeLow.id);
      fillBox(0,0,0,19,9,1,T.drawer.id)}},
  ],
  hallway:[
    {name:'Классика',fill:()=>{
      fillBox(0,18,0,19,19,2,T.top.id);
      fillBox(0,8,0,11,17,2,T.hanging.id);fillBox(12,8,0,19,17,2,T.shelf.id);
      fillBox(0,4,0,19,7,2,T.shoeLow.id);fillBox(0,0,0,19,3,2,T.drawer.id)}},
    {name:'Открытая',fill:()=>{
      fillBox(0,18,0,19,19,2,T.top.id);
      fillBox(0,6,0,19,17,2,T.open.id);
      fillBox(0,0,0,19,5,2,T.shoeLow.id)}},
    {name:'Угловая',fill:()=>{
      fillBox(0,18,0,19,19,2,T.top.id);fillBox(0,18,0,2,19,12,T.top.id);
      fillBox(0,6,0,19,17,2,T.hanging.id);fillBox(0,6,0,2,17,12,T.shelf.id);
      fillBox(0,0,0,19,5,2,T.shoeLow.id);fillBox(0,0,0,2,5,12,T.drawer.id)}},
  ],
  shelving:[
    {name:'Классика',fill:()=>{
      for(let i=0;i<5;i++)fillBox(0,i*4,0,19,i*4+3,1,i%2===0?T.open.id:T.shelf.id)}},
    {name:'Симметрия',fill:()=>{
      for(let i=0;i<5;i++)fillBox(0,i*4,0,19,i*4+3,1,T.shelf.id)}},
    {name:'С ящиками',fill:()=>{
      fillBox(0,8,0,19,19,1,T.shelf.id);
      fillBox(0,4,0,19,7,1,T.open.id);
      fillBox(0,0,0,19,3,1,T.drawer.id)}},
  ],
  kitchen:[
    {name:'Линейная',fill:()=>{
      fillBox(0,14,0,19,19,2,T.shelf.id);
      fillBox(0,0,0,4,7,2,T.sink.id);fillBox(5,0,0,9,7,2,T.drawer.id);
      fillBox(10,4,0,14,7,2,T.cooktop.id);fillBox(10,0,0,14,3,2,T.oven.id);
      fillBox(15,0,0,19,7,2,T.dishw.id)}},
    {name:'Угловая',fill:()=>{
      fillBox(0,14,0,19,19,2,T.shelf.id);fillBox(0,14,0,2,19,10,T.shelf.id);
      fillBox(0,0,0,4,7,2,T.sink.id);fillBox(5,0,0,9,7,2,T.drawer.id);
      fillBox(10,4,0,14,7,2,T.cooktop.id);fillBox(10,0,0,14,3,2,T.oven.id);
      fillBox(15,0,0,19,7,2,T.drawer.id);
      fillBox(0,0,0,2,7,10,T.drawer.id)}},
    {name:'С островом',fill:()=>{
      fillBox(0,14,0,19,19,2,T.shelf.id);
      fillBox(0,0,0,4,7,2,T.sink.id);fillBox(5,0,0,9,7,2,T.drawer.id);
      fillBox(10,4,0,14,7,2,T.cooktop.id);fillBox(10,0,0,14,3,2,T.oven.id);
      fillBox(15,0,0,19,7,2,T.dishw.id);
      fillBox(5,0,8,14,7,11,T.drawer.id)}},
  ],
};

/* ═══════════════════════  STATE  ═══════════════════════ */
let currentBrush=TYPES.shelf.id;
let isEraser=false;
let currentCat='wardrobe';
let activePresetIdx=0;
let splitH=true, splitW=true, splitD=true;

/* ═══════════════════════  DOM REFS  ═══════════════════════ */
const palRow=document.getElementById('pal-row');
const eraserBtn=document.getElementById('eraser-btn');
const presetRow=document.getElementById('preset-row');
const roomWEl=document.getElementById('roomW'),roomDEl=document.getElementById('roomD'),dimHEl=document.getElementById('dimH');
const shelfHEl=document.getElementById('shelfH'),drawerHEl=document.getElementById('drawerH'),
  shoeHEl=document.getElementById('shoeH'),bootHEl=document.getElementById('bootH'),
  bookHEl=document.getElementById('bookH'),openHEl=document.getElementById('openH');
const togH=document.getElementById('tog-h'),togW=document.getElementById('tog-w'),togD=document.getElementById('tog-d');
const subdivInputs=document.getElementById('subdiv-inputs');

/* ═══════════════════════  PALETTE  ═══════════════════════ */
function buildPalette(){
  palRow.innerHTML='';
  CAT_TYPES[currentCat].forEach(k=>{const t=TYPES[k];
    const b=document.createElement('button');b.className='pal-btn';b.dataset.typeId=t.id;
    b.innerHTML=`<span class="sw" style="background:${t.color}"></span>${t.label}`;
    b.addEventListener('click',()=>{isEraser=false;currentBrush=t.id;refreshPal()});
    palRow.appendChild(b)});
  if(!CAT_TYPES[currentCat].some(k=>TYPES[k].id===currentBrush)){
    currentBrush=TYPES[CAT_TYPES[currentCat][0]].id;isEraser=false}
  refreshPal()}
function refreshPal(){
  palRow.querySelectorAll('.pal-btn').forEach(b=>
    b.classList.toggle('active',+b.dataset.typeId===currentBrush&&!isEraser));
  eraserBtn.classList.toggle('active',isEraser);
  document.querySelectorAll('.subdiv-for').forEach(el=>{
    el.style.display=el.dataset.for==String(currentBrush)?'':'none'})}
eraserBtn.addEventListener('click',()=>{isEraser=true;refreshPal()});

function buildPresets(){
  presetRow.innerHTML='';
  const presets=CATEGORY_PRESETS[currentCat]||[];
  presets.forEach((p,i)=>{
    const b=document.createElement('button');b.className='preset-btn'+(i===activePresetIdx?' active':'');
    b.textContent=p.name;
    b.addEventListener('click',()=>{activePresetIdx=i;
      presetRow.querySelectorAll('.preset-btn').forEach((bb,j)=>bb.classList.toggle('active',j===i));
      vClear();p.fill();fullRebuild()});
    presetRow.appendChild(b)})}

/* ═══════════════════════  CATEGORIES  ═══════════════════════ */
document.querySelectorAll('.cat-btn').forEach(b=>b.addEventListener('click',()=>{
  document.querySelector('.cat-btn.active').classList.remove('active');b.classList.add('active');
  currentCat=b.dataset.cat;activePresetIdx=0;
  vClear();const p=CATEGORY_PRESETS[currentCat]?.[0];if(p)p.fill();
  buildPalette();buildPresets();fullRebuild()}));

/* ═══════════════════════  DIMENSIONS / SUBDIVISION  ═══════════════════════ */
togH.addEventListener('click',()=>{splitH=!splitH;togH.classList.toggle('on',splitH);subdivInputs.style.display=splitH?'':'none';scheduleRebuild()});
togW.addEventListener('click',()=>{splitW=!splitW;togW.classList.toggle('on',splitW);scheduleRebuild()});
togD.addEventListener('click',()=>{splitD=!splitD;togD.classList.toggle('on',splitD);scheduleRebuild()});
[roomWEl,roomDEl,dimHEl,shelfHEl,drawerHEl,shoeHEl,bootHEl,bookHEl,openHEl].forEach(el=>
  el.addEventListener('input',()=>scheduleRebuild()));

document.getElementById('btn-clear').addEventListener('click',()=>{vClear();fullRebuild()});
document.getElementById('btn-reset-cam').addEventListener('click',()=>{
  camera.position.set(10,10,10);camera.lookAt(0,0,0);controls.target.set(0,0,0);controls.update()});

/* ═══════════════════════  THREE.JS SETUP  ═══════════════════════ */
const viewEl=document.getElementById('view');
const scene=new THREE.Scene();scene.background=new THREE.Color(0xfdfdfd);
let frustumSize=12;const getA=()=>viewEl.clientWidth/(viewEl.clientHeight||1);
const camera=new THREE.OrthographicCamera(-frustumSize*getA()/2,frustumSize*getA()/2,
  frustumSize/2,-frustumSize/2,.1,1000);
camera.position.set(10,10,10);camera.lookAt(scene.position);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(viewEl.clientWidth,viewEl.clientHeight);viewEl.appendChild(renderer.domElement);
const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;controls.dampingFactor=.12;

/* ═══════════════════════  MATERIALS  ═══════════════════════ */
const TM=new THREE.LineBasicMaterial({color:0x000000,linewidth:1});
const LM=new THREE.LineBasicMaterial({color:0x000000,linewidth:2});
const RM=new THREE.LineBasicMaterial({color:0xdddddd,linewidth:1});
const _matC={};
function getColorMat(hex){if(_matC[hex])return _matC[hex];
  const m=new THREE.MeshBasicMaterial({color:new THREE.Color(hex),transparent:true,opacity:.4,
    depthWrite:false,side:THREE.DoubleSide});_matC[hex]=m;return m}

/* shared geometries */
const unitBox=new THREE.BoxGeometry(1,1,1);
const unitEdges=new THREE.EdgesGeometry(unitBox);

/* ═══════════════════════  SCENE GROUPS  ═══════════════════════ */
const floorGroup=new THREE.Group();scene.add(floorGroup);
const voxGroup=new THREE.Group();scene.add(voxGroup);
const detailGroup=new THREE.Group();scene.add(detailGroup);
const boundsGroup=new THREE.Group();scene.add(boundsGroup);

/* ═══════════════════════  GHOST CUBE  ═══════════════════════ */
const ghostPlaceMat=new THREE.MeshBasicMaterial({color:0x666666,transparent:true,opacity:.2,depthWrite:false});
const ghostEraseMat=new THREE.MeshBasicMaterial({color:0xff4444,transparent:true,opacity:.3,depthWrite:false});
const ghost=new THREE.Mesh(unitBox.clone(),ghostPlaceMat);ghost.visible=false;scene.add(ghost);
const ghostEdge=new THREE.LineSegments(new THREE.EdgesGeometry(unitBox),
  new THREE.LineBasicMaterial({color:0x000000,transparent:true,opacity:.5}));
ghostEdge.visible=false;scene.add(ghostEdge);
let ghostVoxel=null;

/* ═══════════════════════  HELPERS  ═══════════════════════ */
function getDims(){
  const rw=(+roomWEl.value||400)/100,rd=(+roomDEl.value||400)/100,h=(+dimHEl.value||240)/100;
  return{rw,rd,h,cw:rw/GX,ch:h/GY,cd:rd/GZ}}

function v2w(x,y,z){const{rw,rd,cw,ch,cd}=getDims();
  return new THREE.Vector3((x+.5)*cw-rw/2,(y+.5)*ch,(z+.5)*cd-rd/2)}

function wb(parent,w,h,d,x,y,z,mat){mat=mat||TM;
  const g=new THREE.BoxGeometry(w,h,d),e=new THREE.EdgesGeometry(g),
    s=new THREE.LineSegments(e,mat);s.position.set(x,y,z);parent.add(s);return s}

/* ═══════════════════════  FLOOR + BOUNDS  ═══════════════════════ */
function buildFloor(){
  floorGroup.clear();boundsGroup.clear();
  const{rw,rd,h,cw,cd}=getDims();
  /* grid lines on floor */
  const pts=[];
  for(let i=0;i<=GX;i++){const x=i*cw-rw/2;pts.push(new THREE.Vector3(x,0,-rd/2),new THREE.Vector3(x,0,rd/2))}
  for(let j=0;j<=GZ;j++){const z=j*cd-rd/2;pts.push(new THREE.Vector3(-rw/2,0,z),new THREE.Vector3(rw/2,0,z))}
  floorGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts),RM));
  /* room boundary wireframe */
  const be=new THREE.EdgesGeometry(new THREE.BoxGeometry(rw,h,rd));
  const bs=new THREE.LineSegments(be,new THREE.LineBasicMaterial({color:0xaaaaaa}));
  bs.position.set(0,h/2,0);floorGroup.add(bs);
  /* invisible boundary planes for raycasting */
  const invisMat=new THREE.MeshBasicMaterial({visible:false,side:THREE.DoubleSide});
  /* floor */
  const fp=new THREE.Mesh(new THREE.PlaneGeometry(rw,rd),invisMat.clone());
  fp.rotation.x=-Math.PI/2;fp.position.y=-0.001;fp.userData={face:'floor'};boundsGroup.add(fp);
  /* back wall z=-rd/2 */
  const bw=new THREE.Mesh(new THREE.PlaneGeometry(rw,h),invisMat.clone());
  bw.position.set(0,h/2,-rd/2-0.001);bw.userData={face:'back'};boundsGroup.add(bw);
  /* front wall z=+rd/2 */
  const fw=new THREE.Mesh(new THREE.PlaneGeometry(rw,h),invisMat.clone());
  fw.rotation.y=Math.PI;fw.position.set(0,h/2,rd/2+0.001);fw.userData={face:'front'};boundsGroup.add(fw);
  /* left wall x=-rw/2 */
  const lw=new THREE.Mesh(new THREE.PlaneGeometry(rd,h),invisMat.clone());
  lw.rotation.y=Math.PI/2;lw.position.set(-rw/2-0.001,h/2,0);lw.userData={face:'left'};boundsGroup.add(lw);
  /* right wall x=+rw/2 */
  const rww=new THREE.Mesh(new THREE.PlaneGeometry(rd,h),invisMat.clone());
  rww.rotation.y=-Math.PI/2;rww.position.set(rw/2+0.001,h/2,0);rww.userData={face:'right'};boundsGroup.add(rww);
}

/* ═══════════════════════  VOXEL MESHES  ═══════════════════════ */
const voxMeshMap={};
function addVoxMesh(x,y,z,typeId){
  const key=`${x},${y},${z}`;removeVoxMesh(x,y,z);
  if(!typeId)return;
  const info=TYPE_BY_ID[typeId];if(!info)return;
  const{cw,ch,cd}=getDims();const pos=v2w(x,y,z);
  const mesh=new THREE.Mesh(unitBox,getColorMat(info.color));
  mesh.position.copy(pos);mesh.scale.set(cw*.96,ch*.96,cd*.96);
  mesh.userData={vx:x,vy:y,vz:z};voxGroup.add(mesh);
  const wire=new THREE.LineSegments(unitEdges,TM);
  wire.position.copy(pos);wire.scale.set(cw*.96,ch*.96,cd*.96);voxGroup.add(wire);
  voxMeshMap[key]={mesh,wire}}
function removeVoxMesh(x,y,z){
  const key=`${x},${y},${z}`,e=voxMeshMap[key];if(!e)return;
  voxGroup.remove(e.mesh);voxGroup.remove(e.wire);delete voxMeshMap[key]}
function rebuildAllVoxMeshes(){
  for(const e of Object.values(voxMeshMap)){voxGroup.remove(e.mesh);voxGroup.remove(e.wire)}
  for(const k in voxMeshMap)delete voxMeshMap[k];
  for(let z=0;z<GZ;z++)for(let y=0;y<GY;y++)for(let x=0;x<GX;x++){
    const v=vGet(x,y,z);if(v)addVoxMesh(x,y,z,v)}}

/* ═══════════════════════  POINTER INTERACTION  ═══════════════════════ */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let pointerDownPos=null;

function getVoxMeshes(){return Object.values(voxMeshMap).map(e=>e.mesh)}

function updateGhost(e){
  const rect=renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(mouse,camera);
  ghostVoxel=null;ghost.visible=false;ghostEdge.visible=false;
  const{rw,rd,h,cw,ch,cd}=getDims();

  if(isEraser){
    /* eraser: highlight existing cube */
    const hits=raycaster.intersectObjects(getVoxMeshes(),false);
    if(hits.length>0){
      const{vx,vy,vz}=hits[0].object.userData;
      ghostVoxel={x:vx,y:vy,z:vz};
      const pos=v2w(vx,vy,vz);
      ghost.position.copy(pos);ghost.scale.set(cw,ch,cd);ghost.material=ghostEraseMat;ghost.visible=true;
      ghostEdge.position.copy(pos);ghostEdge.scale.set(cw,ch,cd);ghostEdge.visible=true}
    return}

  /* normal: find adjacent empty cell */
  const voxHits=raycaster.intersectObjects(getVoxMeshes(),false);
  const boundHits=raycaster.intersectObjects(boundsGroup.children,false);
  /* merge and sort by distance */
  const allHits=[...voxHits.map(h=>({hit:h,src:'vox'})),...boundHits.map(h=>({hit:h,src:'bound'}))];
  allHits.sort((a,b)=>a.hit.distance-b.hit.distance);
  for(const{hit,src}of allHits){
    let gx,gy,gz;
    if(src==='vox'){
      const n=hit.face.normal;
      gx=hit.object.userData.vx+Math.round(n.x);
      gy=hit.object.userData.vy+Math.round(n.y);
      gz=hit.object.userData.vz+Math.round(n.z);
    }else{
      const f=hit.object.userData.face,p=hit.point;
      if(f==='floor'){gx=Math.floor((p.x+rw/2)/cw);gy=0;gz=Math.floor((p.z+rd/2)/cd)}
      else if(f==='back'){gx=Math.floor((p.x+rw/2)/cw);gy=Math.floor(p.y/ch);gz=0}
      else if(f==='front'){gx=Math.floor((p.x+rw/2)/cw);gy=Math.floor(p.y/ch);gz=GZ-1}
      else if(f==='left'){gx=0;gy=Math.floor(p.y/ch);gz=Math.floor((p.z+rd/2)/cd)}
      else{gx=GX-1;gy=Math.floor(p.y/ch);gz=Math.floor((p.z+rd/2)/cd)}
    }
    if(gx>=0&&gx<GX&&gy>=0&&gy<GY&&gz>=0&&gz<GZ&&!vGet(gx,gy,gz)){
      ghostVoxel={x:gx,y:gy,z:gz};
      const pos=v2w(gx,gy,gz);
      ghost.position.copy(pos);ghost.scale.set(cw,ch,cd);ghost.material=ghostPlaceMat;ghost.visible=true;
      ghostEdge.position.copy(pos);ghostEdge.scale.set(cw,ch,cd);ghostEdge.visible=true;
      break}
  }
}

renderer.domElement.addEventListener('pointermove',updateGhost);
renderer.domElement.addEventListener('pointerdown',e=>{pointerDownPos={x:e.clientX,y:e.clientY}});
renderer.domElement.addEventListener('pointerup',e=>{
  if(!pointerDownPos)return;
  const dx=e.clientX-pointerDownPos.x,dy=e.clientY-pointerDownPos.y;
  pointerDownPos=null;
  if(Math.abs(dx)>5||Math.abs(dy)>5)return; /* was drag, not click */
  if(!ghostVoxel)return;
  const{x,y,z}=ghostVoxel;
  if(isEraser){
    vSet(x,y,z,0);removeVoxMesh(x,y,z);
  }else{
    vSet(x,y,z,currentBrush);addVoxMesh(x,y,z,currentBrush);
  }
  scheduleDetailRebuild();
  updateGhost(e)});
renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());

/* ═══════════════════════  3D FLOOD FILL  ═══════════════════════ */
function findRegions3D(){
  const vis=new Uint8Array(GX*GY*GZ),regs=[];
  for(let z=0;z<GZ;z++)for(let y=0;y<GY;y++)for(let x=0;x<GX;x++){
    const idx=vIdx(x,y,z);if(vis[idx]||!voxels[idx])continue;
    const tid=voxels[idx],cells=[],q=[[x,y,z]];vis[idx]=1;
    while(q.length){const[cx,cy,cz]=q.shift();cells.push([cx,cy,cz]);
      for(const[dx,dy,dz]of[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]]){
        const nx=cx+dx,ny=cy+dy,nz=cz+dz;
        if(nx<0||nx>=GX||ny<0||ny>=GY||nz<0||nz>=GZ)continue;
        const ni=vIdx(nx,ny,nz);if(vis[ni]||voxels[ni]!==tid)continue;vis[ni]=1;q.push([nx,ny,nz])}}
    let minX=GX,maxX=0,minY=GY,maxY=0,minZ=GZ,maxZ=0;
    for(const[cx,cy,cz]of cells){minX=Math.min(minX,cx);maxX=Math.max(maxX,cx);
      minY=Math.min(minY,cy);maxY=Math.max(maxY,cy);minZ=Math.min(minZ,cz);maxZ=Math.max(maxZ,cz)}
    regs.push({typeId:tid,cells,minX,maxX,minY,maxY,minZ,maxZ})}
  return regs}

function findFrontFace(reg){
  let faces={nx:0,px:0,nz:0,pz:0};
  for(const[x,y,z]of reg.cells){
    if(x===reg.minX&&!vGet(x-1,y,z))faces.nx++;
    if(x===reg.maxX&&!vGet(x+1,y,z))faces.px++;
    if(z===reg.minZ&&!vGet(x,y,z-1))faces.nz++;
    if(z===reg.maxZ&&!vGet(x,y,z+1))faces.pz++;
  }
  let best='pz',bv=faces.pz;
  if(faces.nz>bv){best='nz';bv=faces.nz}
  if(faces.px>bv){best='px';bv=faces.px}
  if(faces.nx>bv){best='nx';bv=faces.nx}
  return best}

/* ═══════════════════════  DETAIL RENDERING  ═══════════════════════ */
function buildDetails(){
  detailGroup.clear();
  const{rw,rd,h,cw,ch,cd}=getDims();const WALL=.015;
  const tShelf=(+shelfHEl.value||30)/100,tDrawer=(+drawerHEl.value||20)/100,
    tShoe=(+shoeHEl.value||18)/100,tBoot=(+bootHEl.value||35)/100,
    tBook=(+bookHEl.value||30)/100,tOpen=(+openHEl.value||35)/100;
  const regs=findRegions3D();
  document.getElementById('info-regions').textContent=regs.length;

  for(const reg of regs){
    const info=TYPE_BY_ID[reg.typeId];if(!info)continue;
    const bx1=reg.minX*cw-rw/2, bx2=(reg.maxX+1)*cw-rw/2;
    const by1=reg.minY*ch, by2=(reg.maxY+1)*ch;
    const bz1=reg.minZ*cd-rd/2, bz2=(reg.maxZ+1)*cd-rd/2;
    const bW=bx2-bx1,bH=by2-by1,bD=bz2-bz1;
    const bcx=(bx1+bx2)/2,bcy=(by1+by2)/2,bcz=(bz1+bz2)/2;
    const inW=bW-WALL*4,inH=bH-WALL*4,inD=bD-WALL*4;
    const front=findFrontFace(reg);

    switch(info.key){
      case 'shelf':case 'open':{
        const tgt=info.key==='shelf'?tShelf:tOpen;
        if(splitH){const n=Math.max(1,Math.round(bH/tgt));
          for(let i=1;i<n;i++)wb(detailGroup,inW,WALL,inD,bcx,by1+bH*i/n,bcz)}
        if(splitW&&bW>cw*4)wb(detailGroup,WALL,inH,inD,bcx,bcy,bcz);
        if(splitD&&bD>cd*4)wb(detailGroup,inW,inH,WALL,bcx,bcy,bcz);break}
      case 'books':{
        if(splitH){const n=Math.max(1,Math.round(bH/tBook));
          for(let i=1;i<n;i++)wb(detailGroup,inW,WALL,inD,bcx,by1+bH*i/n,bcz)}
        if(splitW&&bW>cw*3)wb(detailGroup,WALL,inH,inD,bcx,bcy,bcz);
        if(splitD&&bD>cd*3)wb(detailGroup,inW,inH,WALL,bcx,bcy,bcz);break}
      case 'hanging':{
        const ry=by2-bH*.1;
        const rodLen=front==='nz'||front==='pz'?inW:inD;
        const rg=new THREE.CylinderGeometry(.01,.01,rodLen,8);
        if(front==='nz'||front==='pz')rg.rotateZ(Math.PI/2);else rg.rotateX(Math.PI/2);
        const re=new THREE.EdgesGeometry(rg),rod=new THREE.LineSegments(re,LM);
        rod.position.set(bcx,ry,bcz);detailGroup.add(rod);
        wb(detailGroup,inW,WALL,inD,bcx,by2-WALL*2,bcz);
        if(splitW&&bW>cw*4)wb(detailGroup,WALL,inH,inD,bcx,bcy,bcz);break}
      case 'drawer':{
        if(splitH){const n=Math.max(1,Math.round(bH/tDrawer));
          const gap=WALL,dH=(bH-gap*(n+1))/n;
          let ffx=bcx,ffz=bcz;
          if(front==='nz')ffz=bz1+WALL;else if(front==='pz')ffz=bz2-WALL;
          else if(front==='nx')ffx=bx1+WALL;else ffx=bx2-WALL;
          for(let i=0;i<n;i++){const dy=by1+gap+dH/2+i*(dH+gap);
            if(front==='nz'||front==='pz'){
              wb(detailGroup,inW,dH-WALL,WALL,bcx,dy,ffz);
              wb(detailGroup,inW*.22,WALL,WALL,bcx,dy,ffz+(front==='pz'?WALL:-WALL));
            }else{
              wb(detailGroup,WALL,dH-WALL,inD,ffx,dy,bcz);
              wb(detailGroup,WALL,WALL,inD*.22,ffx+(front==='px'?WALL:-WALL),dy,bcz)}}}
        if(splitW&&bW>cw*4)wb(detailGroup,WALL,inH,inD,bcx,bcy,bcz);break}
      case 'shoeLow':case 'shoeHi':{
        const tgt=info.key==='shoeLow'?tShoe:tBoot;
        const ratio=info.key==='shoeLow'?.55:.7;
        const angle=info.key==='shoeLow'?.3:.2;
        if(splitH){const n=Math.max(1,Math.round(bH/tgt));
          for(let i=0;i<n;i++){const sy=by1+bH*(i+.5)/n;
            const szW=front==='nz'||front==='pz'?inW:inD;
            const szD=front==='nz'||front==='pz'?bD*ratio:bW*ratio;
            const pg=new THREE.PlaneGeometry(szW,szD);
            const pe=new THREE.EdgesGeometry(pg),pl=new THREE.LineSegments(pe,TM);
            if(front==='nz'||front==='pz')pl.rotation.x=-Math.PI/2+angle;
            else pl.rotation.z=Math.PI/2-angle;
            pl.position.set(bcx,sy,bcz);detailGroup.add(pl)}}break}
      case 'top':{
        if(splitH)wb(detailGroup,inW,WALL,inD,bcx,bcy,bcz);
        if(splitW&&bW>cw*4)wb(detailGroup,WALL,inH,inD,bcx,bcy,bcz);break}
      case 'sink':{
        const basinH=bH*.2,basinW=inW*.65,basinD=inD*.65;
        const basinG=new THREE.BoxGeometry(basinW,basinH,basinD);
        const basinE=new THREE.EdgesGeometry(basinG);
        const basinL=new THREE.LineSegments(basinE,TM);
        basinL.position.set(bcx,by2-basinH/2-WALL,bcz);detailGroup.add(basinL);
        const fH=bH*.3;const fG=new THREE.CylinderGeometry(.006,.006,fH,6);
        const fE=new THREE.EdgesGeometry(fG),fL=new THREE.LineSegments(fE,LM);
        let faucZ=bcz,faucX=bcx;
        if(front==='nz')faucZ=bz1+inD*.2;else if(front==='pz')faucZ=bz2-inD*.2;
        else if(front==='nx')faucX=bx1+inW*.2;else faucX=bx2-inW*.2;
        fL.position.set(faucX,by2+fH/2-WALL,faucZ);detailGroup.add(fL);break}
      case 'cooktop':{
        wb(detailGroup,inW*.9,WALL*2,inD*.9,bcx,by2-WALL*2,bcz,LM);
        const bR=Math.min(inW,inD)*.16;
        const offX=inW*.2,offZ=inD*.2;
        for(const[dx,dz]of[[-1,-1],[-1,1],[1,-1],[1,1]]){
          const cg=new THREE.RingGeometry(bR*.5,bR,16);cg.rotateX(-Math.PI/2);
          const ce=new THREE.EdgesGeometry(cg),cl=new THREE.LineSegments(ce,TM);
          cl.position.set(bcx+dx*offX,by2-WALL,bcz+dz*offZ);detailGroup.add(cl)}break}
      case 'oven':{
        let dx=0,dz=0;
        if(front==='nz')dz=bz1+WALL;else if(front==='pz')dz=bz2-WALL;
        else if(front==='nx')dx=bx1+WALL;else dx=bx2-WALL;
        if(front==='nz'||front==='pz'){
          wb(detailGroup,inW-WALL*4,inH-WALL*4,WALL,bcx,bcy,dz);
          wb(detailGroup,inW*.45,WALL,WALL,bcx,by2-bH*.15,dz+(front==='pz'?WALL:-WALL),LM);
        }else{
          wb(detailGroup,WALL,inH-WALL*4,inD-WALL*4,dx,bcy,bcz);
          wb(detailGroup,WALL,WALL,inD*.45,dx+(front==='px'?WALL:-WALL),by2-bH*.15,bcz,LM)}
        wb(detailGroup,inW*.8,WALL,inD*.8,bcx,bcy,bcz);break}
      case 'dishw':{
        let dx=0,dz=0;
        if(front==='nz')dz=bz1+WALL;else if(front==='pz')dz=bz2-WALL;
        else if(front==='nx')dx=bx1+WALL;else dx=bx2-WALL;
        if(front==='nz'||front==='pz'){
          wb(detailGroup,inW-WALL*4,inH-WALL*4,WALL,bcx,bcy,dz);
          wb(detailGroup,inW*.35,WALL,WALL,bcx,by2-bH*.12,dz+(front==='pz'?WALL:-WALL),LM);
        }else{
          wb(detailGroup,WALL,inH-WALL*4,inD-WALL*4,dx,bcy,bcz);
          wb(detailGroup,WALL,WALL,inD*.35,dx+(front==='px'?WALL:-WALL),by2-bH*.12,bcz,LM)}
        if(splitH){wb(detailGroup,inW*.8,WALL,inD*.8,bcx,by1+bH*.35,bcz);
          wb(detailGroup,inW*.8,WALL,inD*.8,bcx,by1+bH*.65,bcz)}break}
    }
  }
}

/* ═══════════════════════  INFO UPDATE  ═══════════════════════ */
function updateInfo(){
  const{cw,ch,cd}=getDims();
  let minX=GX,maxX=-1,minY=GY,maxY=-1,minZ=GZ,maxZ=-1;
  for(let z=0;z<GZ;z++)for(let y=0;y<GY;y++)for(let x=0;x<GX;x++){
    if(!vGet(x,y,z))continue;
    minX=Math.min(minX,x);maxX=Math.max(maxX,x);
    minY=Math.min(minY,y);maxY=Math.max(maxY,y);
    minZ=Math.min(minZ,z);maxZ=Math.max(maxZ,z)}
  if(maxX<0){
    document.getElementById('auto-w').textContent='—';
    document.getElementById('auto-h').textContent='—';
    document.getElementById('auto-d').textContent='—';
    document.getElementById('info-size').textContent='—';return}
  const w=((maxX-minX+1)*cw*100).toFixed(0);
  const ht=((maxY-minY+1)*ch*100).toFixed(0);
  const d=((maxZ-minZ+1)*cd*100).toFixed(0);
  document.getElementById('auto-w').textContent=w;
  document.getElementById('auto-h').textContent=ht;
  document.getElementById('auto-d').textContent=d;
  document.getElementById('info-size').textContent=`${w}×${ht}×${d} см`}

/* ═══════════════════════  REBUILD  ═══════════════════════ */
let timer=0,detailTimer=0;
function scheduleRebuild(){clearTimeout(timer);timer=setTimeout(fullRebuild,80)}
function scheduleDetailRebuild(){clearTimeout(detailTimer);detailTimer=setTimeout(()=>{buildDetails();updateInfo()},100)}

function fullRebuild(){
  buildFloor();rebuildAllVoxMeshes();buildDetails();updateInfo();fitCam()}

/* ═══════════════════════  CAMERA  ═══════════════════════ */
function fitCam(){
  const{rw,rd,h}=getDims();
  const sz=Math.max(rw,rd,h);
  frustumSize=sz*1.6;updateFrustum();
  controls.target.set(0,h/2,0);controls.update()}

function updateFrustum(){const a=getA();
  camera.left=-frustumSize*a/2;camera.right=frustumSize*a/2;
  camera.top=frustumSize/2;camera.bottom=-frustumSize/2;camera.updateProjectionMatrix()}
window.addEventListener('resize',()=>{renderer.setSize(viewEl.clientWidth,viewEl.clientHeight);updateFrustum()});
new ResizeObserver(()=>{renderer.setSize(viewEl.clientWidth,viewEl.clientHeight);updateFrustum()}).observe(viewEl);

(function animate(){requestAnimationFrame(animate);controls.update();renderer.render(scene,camera)})();

/* ═══════════════════════  INIT  ═══════════════════════ */
buildPalette();buildPresets();
const initPreset=CATEGORY_PRESETS.wardrobe[0];
if(initPreset)initPreset.fill();
fullRebuild();
</script>
</body>
</html>
